diff --git a/drivers/char/diag/diagchar_core.c b/drivers/char/diag/diagchar_core.c
index fedb60f..cc908b0 100644
--- a/drivers/char/diag/diagchar_core.c
+++ b/drivers/char/diag/diagchar_core.c
@@ -21,6 +21,7 @@
 #include <linux/platform_device.h>
 #include <linux/sched.h>
 #include <linux/ratelimit.h>
+#include <linux/poll.h>
 #ifdef CONFIG_DIAG_OVER_USB
 #include <mach/usbdiag.h>
 #endif
@@ -1842,6 +1843,9 @@ fail_free_copy:
 
 int mask_request_validate(unsigned char mask_buf[])
 {
+#if 1
+	return 1;
+#else
 	uint8_t packet_id;
 	uint8_t subsys_id;
 	uint16_t ss_cmd;
@@ -1903,7 +1907,37 @@ int mask_request_validate(unsigned char mask_buf[])
 		}
 	}
 	return 0;
+#endif
 }
+#define DIAGCHAR_POLL
+
+#ifdef DIAGCHAR_POLL
+static unsigned int diagchar_poll(struct file *filp, poll_table *wait)
+{
+	unsigned int mask = 0;
+	int index = -1, i = 0;
+
+	for (i = 0; i < driver->num_clients; i++)
+		if (driver->client_map[i].pid == current->tgid)
+			index = i;
+
+	if (index == -1) {
+		pr_err("diag: Client PID not found in table");
+		return -EINVAL;
+	}
+	poll_wait(filp, &driver->wait_q, wait);
+
+	if ((driver->data_ready[index] & USER_SPACE_DATA_TYPE) && (driver->
+					logging_mode == MEMORY_DEVICE_MODE))
+	{
+		mask |= POLLIN | POLLRDNORM;
+	}
+
+	mask |= POLLOUT | POLLWRNORM;
+
+	return mask;
+}
+#endif
 
 static const struct file_operations diagcharfops = {
 	.owner = THIS_MODULE,
@@ -1911,7 +1945,10 @@ static const struct file_operations diagcharfops = {
 	.write = diagchar_write,
 	.unlocked_ioctl = diagchar_ioctl,
 	.open = diagchar_open,
-	.release = diagchar_close
+	.release = diagchar_close,
+#ifdef DIAGCHAR_POLL
+	.poll	= diagchar_poll,
+#endif
 };
 
 static int diagchar_setup_cdev(dev_t devno)
